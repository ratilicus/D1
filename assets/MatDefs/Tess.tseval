/*
Height Map Tesselation Control Shader
By: Adam Dybczak

*/


#import "Common/ShaderLib/Instancing.glsllib"

layout (triangles) in;

in vec2 tcTexCoord[];
out vec2 texCoord;

in vec3 tcAmbientSum[];
in vec4 tcDiffuseSum[];
in vec3 tcSpecularSum[];

in vec3 tcViewDir[];
in vec4 tcLightDir[];
in vec3 tcNormal[];

out vec3 AmbientSum;
out vec4 DiffuseSum;
out vec3 SpecularSum;

out vec3 vViewDir;
out vec4 vLightDir;
out vec3 vNormal;

out vec3 p;
out vec3 pu;
out vec3 pv;
out vec2 tu;
out vec2 tv;

uniform sampler2D m_DiffuseMap;
uniform float m_SphereRadius;

float getHeight(sampler2D tex, vec2 tc) {
    vec2 t1 = vec2(fract(tc[1] * 10.0), fract(tc[0] * 10.0));
    vec2 t2 = vec2(fract(tc[0] * 100.0), fract(tc[1] * 100.0));
    vec2 t3 = vec2(fract(tc[0] * 1000.0), fract(tc[1] * 1000.0));

    vec4 c1 = texture2D(tex, tc);
    vec4 c2 = texture2D(tex, t1)-0.5;
    vec4 c3 = texture2D(tex, t2)-0.5;
    vec4 c4 = texture2D(tex, t3)-0.5;
    float h = 0.9*c1.r + 0.1*c2.g + 0.05*c3.b + 0.002*c4.r;

    float b_water = 0.55;

    h = clamp(h, b_water, 1.0)-b_water;

    return 1.0+0.1*h;
}

void main(){	

    texCoord = (
        gl_TessCoord.x * tcTexCoord[0]+
        gl_TessCoord.y * tcTexCoord[1]+
        gl_TessCoord.z * tcTexCoord[2]);

    gl_Position = (
        gl_TessCoord.x * gl_in[0].gl_Position +
        gl_TessCoord.y * gl_in[1].gl_Position +
        gl_TessCoord.z * gl_in[2].gl_Position);

    p = normalize(gl_Position.xyz);
    gl_Position.xyz = p * m_SphereRadius * getHeight(m_DiffuseMap, texCoord);

    AmbientSum = (
        gl_TessCoord.x * tcAmbientSum[0] +
        gl_TessCoord.y * tcAmbientSum[1] +
        gl_TessCoord.z * tcAmbientSum[2]);

    DiffuseSum = (
        gl_TessCoord.x * tcDiffuseSum[0] +
        gl_TessCoord.y * tcDiffuseSum[1] +
        gl_TessCoord.z * tcDiffuseSum[2]);

    SpecularSum = (
        gl_TessCoord.x * tcSpecularSum[0] +
        gl_TessCoord.y * tcSpecularSum[1] +
        gl_TessCoord.z * tcSpecularSum[2]);

    vViewDir = (
        gl_TessCoord.x * tcViewDir[0] +
        gl_TessCoord.y * tcViewDir[1] +
        gl_TessCoord.z * tcViewDir[2]);

    vLightDir = (
        gl_TessCoord.x * tcLightDir[0] +
        gl_TessCoord.y * tcLightDir[1] +
        gl_TessCoord.z * tcLightDir[2]);

//    vec3 a = gl_in[0].gl_Position.xyz * m_SphereRadius * getHeight(m_DiffuseMap, tcTexCoord[0]);
//    vec3 b = gl_in[1].gl_Position.xyz * m_SphereRadius * getHeight(m_DiffuseMap, tcTexCoord[1]);
//    vec3 c = gl_in[2].gl_Position.xyz * m_SphereRadius * getHeight(m_DiffuseMap, tcTexCoord[2]);

    tu = tcTexCoord[0] - texCoord;
    tv = tcTexCoord[1] - texCoord;

    pu = normalize(gl_in[0].gl_Position.xyz) - p;
    pv = normalize(gl_in[1].gl_Position.xyz) - p;
    

//    vNormal = normalize(TransformNormal(gl_Position.xyz));
    gl_Position = TransformWorldViewProjection(gl_Position);
}

